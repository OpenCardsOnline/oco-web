package database

import (
	"context"
	"fmt"
	"log"
	"os"
	"path/filepath"

	"github.com/jackc/pgx/v5"
	"github.com/opencardsonline/oco-web/config"
	logger "github.com/opencardsonline/oco-web/internal/logging"
)

var migrationTableName = "migration_history"

func RunMigrations() {
	appConfig := config.AppConfig{}
	appConfig.LoadEnvVars()

	db := InitializeDBConnection(appConfig.DBConnectionString)

	mStruct := &MigrationStruct{}
	mStruct.New(db)

	mStruct.InitializeMigrationHistoryTable()
	migrationFiles := mStruct.getAllMigrationFiles()
	migrationsInDB := mStruct.getMigrationsInDB()
	migrationsToRun := mStruct.compareMigrationsToRun(migrationFiles, migrationsInDB)
	mStruct.performMigrations(migrationsToRun)
}

type MigrationStruct struct {
	db *pgx.Conn
}

func (_m *MigrationStruct) New(db *pgx.Conn) {
	db = db
}

func (_m *MigrationStruct) InitializeMigrationHistoryTable() {
	sql := fmt.Sprintf(`
		CREATE TABLE IF NOT EXISTS "%s" (
		"id" INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
		"created_at" timestamp DEFAULT (now()),
		"filename" text
		);
	`, migrationTableName)
	_, err := _m.db.Exec(context.Background(), sql)
	if err != nil {
		fmt.Print(err.Error())
	}

}

type MigrationFile struct {
	Filename string
	SQL      string
}

func (_m *MigrationStruct) getAllMigrationFiles() []MigrationFile {
	migrationsDir := "./migrations"

	files, err := os.ReadDir(migrationsDir)
	if err != nil {
		log.Fatalf("failed to read directory: %v", err)
	}

	var migrationFiles []MigrationFile

	for _, file := range files {
		if filepath.Ext(file.Name()) == ".sql" {
			filePath := filepath.Join(migrationsDir, file.Name())

			content, err := os.ReadFile(filePath)
			if err != nil {
				log.Printf("failed to read file %s: %v", filePath, err)
				continue
			}

			migrationFiles = append(migrationFiles, *(&MigrationFile{
				Filename: file.Name(),
				SQL:      string(content),
			}))
		}
	}

	return migrationFiles
}

func (_m *MigrationStruct) getMigrationsInDB() []string {

	sql := fmt.Sprintf(`
		SELECT filename 
			FROM public.%s
		ORDER BY created_at ASC 
	`, migrationTableName)
	rows, err := _m.db.Query(context.Background(), sql)
	if err != nil {
		fmt.Print(err.Error())
	}

	var filenames []string

	for rows.Next() {
		var value string
		if err := rows.Scan(&value); err != nil {
			log.Fatalf("Failed to scan row: %v", err)
		}
		filenames = append(filenames, value)
	}

	return filenames
}

func (_m *MigrationStruct) compareMigrationsToRun(migrationFiles []MigrationFile, migrationsInDB []string) []MigrationFile {
	var filesToRun []MigrationFile

	contains := func(arr []string, value string) bool {
		for _, v := range arr {
			if v == value {
				return true
			}
		}
		return false
	}

	for _, migration := range migrationFiles {
		if !contains(migrationsInDB, migration.Filename) {
			filesToRun = append(filesToRun, migration)
		}
	}

	return filesToRun
}

func (_m *MigrationStruct) performMigrations(migrations []MigrationFile) {

	if len(migrations) > 0 {
		for _, migration := range migrations {

			logger.Log.Info("New Migration: " + migration.Filename)
			logger.Log.Info(migration.SQL)

			_, err := _m.db.Exec(context.Background(), migration.SQL)
			if err != nil {
				fmt.Print(err.Error())
			} else {
				sql := fmt.Sprintf(`
					INSERT INTO public.%s (
						filename
					) 
					VALUES ($1)
			`, migrationTableName)
				_, err = _m.db.Exec(context.Background(), sql, migration.Filename)
				if err != nil {
					fmt.Print(err.Error())
				}
			}
		}

		logger.Log.Info("Migrations Completed!")
	} else {
		logger.Log.Info("No new migrations to run!")
	}
}
